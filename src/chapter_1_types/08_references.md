## 熟悉引用和指针类型

对于一般编程而言，引用是一种间接访问某个数据结构的方式，与拥有该数据结构的变量无关。在实践中，这通常被实现为指针：一个数字，其值是数据结构在内存中的地址。

现代 CPU 通常会对指针施加一些限制 - 内存地址应在有效的内存范围内（无论是虚拟的还是物理的），并且可能需要对齐（例如，只有当 4 字节整数值的地址是 4 的倍数时才可以访问它）。

但是，高级编程语言通常会在其类型系统中编码有关指针的更多信息。在包括 Rust 在内的 C 派生语言中，指针具有一种类型，该类型指示指向的内存地址处预期存在哪种数据结构。这允许代码解释该地址处的内存内容以及该地址之后的内存中的内容。

这种基本级别的指针信息 - 假定的内存位置和预期的数据结构布局 - 在 Rust 中表示为原始指针。但是，安全的 Rust 代码不使用原始指针，因为 Rust 提供了更丰富的引用和指针类型，可提供额外的安全保证和约束。这些引用和指针类型是本条款的主题；原始指针被归入条款 16（讨论不安全代码）。

### Rust引用

Rust 中最普遍的指针类类型是引用，其类型写为 &T，用于表示某个类型 T。尽管这是一个指针值，但编译器会确保遵守有关其使用的各种规则：它必须始终指向相关类型 T 的有效、正确对齐的实例，其生命周期（第 14 条）超出其使用范围，并且必须满足借用检查规则（第 15 条）。Rust 中的术语“引用”始终暗示这些额外的约束，因此裸术语“指针”通常很少见。

Rust 引用必须指向有效、正确对齐的项目这一约束与 C++ 的引用类型相同。但是，C++ 没有生命周期的概念，因此允许使用悬垂引用：

```cpp
// C++
const int& dangle() {
  int x = 32; // on the stack, overwritten later
  return x; // return reference to stack variable!
}
```

Rust 的借用和生命周期检查意味着等效代码甚至无法编译：

```rust
fn dangle() -> &'static i64 {
    let x: i64 = 32; // on the stack
    &x
}
```

```rust
error[E0515]: cannot return reference to local variable `x`
   --> src/main.rs:477:5
    |
477 |     &x
    |     ^^ returns a reference to data owned by the current function
```

Rust 引用 &T 允许对底层项进行只读访问（大致相当于 C++ 的 const T&）。可变引用也允许修改底层项，写作 &mut T，并且也受条款 15 中讨论的借用检查规则的约束。这种命名模式反映了 Rust 和 C++ 之间略有不同的思维方式：

在 Rust 中，默认变体是只读的，可写类型被特殊标记（使用 mut）。
在 C++ 中，默认变体是可写的，只读类型被特殊标记（使用 const）。
编译器将使用引用的 Rust 代码转换为使用简单指针的机器代码，在 64 位平台上大小为 8 个字节（本条款始终假设如此）。例如，一对局部变量及其引用：

```rust
pub struct Point {
    pub x: u32,
    pub y: u32,
}

let pt = Point { x: 1, y: 2 };
let x = 0u64;
let ref_x = &x;
let ref_pt = &pt;
```

最终可能会如图 1-2 所示排列在堆栈上：

![](https://effective-rust.com/images/stack.svg)


